diff -ur tf-50b3/src/globals.h tfmod/src/globals.h
--- tf-50b3/src/globals.h	Tue Jan  6 01:11:04 2004
+++ tfmod/src/globals.h	Mon Jan  5 23:28:48 2004
@@ -209,6 +209,7 @@
 #define sockmload	getintvar(VAR_sockmload)
 #define status_fields	getstdvar(VAR_stat_fields)
 #define status_pad	getstdvar(VAR_stat_pad)
+#define status_height	getintvar(VAR_stat_height)
 #define sub		getintvar(VAR_sub)
 #define tabsize		getintvar(VAR_tabsize)
 #define telopt		getintvar(VAR_telopt)
diff -ur tf-50b3/src/output.c tfmod/src/output.c
--- tf-50b3/src/output.c	Tue Jan  6 01:11:04 2004
+++ tfmod/src/output.c	Tue Jan  6 00:27:03 2004
@@ -15,6 +15,8 @@
  * Handles all screen-related phenomena.
  *****************************************************************/
 
+#define MAX_STATUS_HEIGHT 5
+
 #define TERM_vt100	1
 #define TERM_vt220	2
 #define TERM_ansi	3
@@ -392,15 +394,15 @@
     lines = ((str = getvar("LINES"))) ? atoi(str) : 0;
     columns = ((str = getvar("COLUMNS"))) ? atoi(str) : 0;
     if (lines <= 0 || columns <= 0) get_window_size();
-    ystatus = lines - isize;
+    ystatus = lines - isize - (status_height-1);
     top_margin = 1;
     bottom_margin = lines;
 
     prompt = fgprompt();
 
     init_term();
-    Stringninit(status_line, columns);
-    check_charattrs(status_line, columns, 0, __FILE__, __LINE__);
+    Stringninit(status_line, columns*MAX_STATUS_HEIGHT);
+    check_charattrs(status_line, columns*MAX_STATUS_HEIGHT, 0, __FILE__, __LINE__);
     ch_hiliteattr();
     ch_alert_attr();
     redraw();
@@ -657,7 +659,7 @@
     } else {
         prompt = fgprompt();
         if (isize > lines - 3) set_var_by_id(VAR_isize, lines - 3);
-        ystatus = lines - isize;
+        ystatus = lines - isize - (status_height - 1);
 #if 0
         outcount = ystatus - 1;
 #endif
@@ -668,7 +670,7 @@
         }
         update_status_line();
         ix = iendx = oy = 1;
-        iy = iendy = istarty = ystatus + 1;
+        iy = iendy = istarty = ystatus + status_height;
         ipos();
 #endif
     }
@@ -1282,8 +1284,8 @@
     }
 
     if (width > columns) {
-        eprintf("status_fields: status width (%d) is wider than screen (%d)",
-	    width, columns);
+//        eprintf("status_fields: status width (%d) is wider than screen (%d)",
+//	    width, columns);
     }
 
     /* update new fields */
@@ -1374,21 +1376,21 @@
 {
     int column;
     if (field->column >= 0)
-	return (field->column > columns) ? columns : field->column;
+	return (field->column > columns*status_height) ? columns*status_height : field->column;
     column = field->column +
-	((status_left + status_right > columns) ?
-	status_left + status_right : columns);
-    return (column > columns) ? columns : column;
+	((status_left + status_right > columns*status_height) ?
+	status_left + status_right : columns*status_height);
+    return (column > columns*status_height) ? columns*status_height : column;
 }
 
 static int status_width(StatusField *field, int start)
 {
     int width;
-    if (start >= columns) return 0;
-    width = (field->width == 0) ? columns - status_right - status_left :
+    if (start >= columns*status_height) return 0;
+    width = (field->width == 0) ? columns*status_height - status_right - status_left :
 	(field->width > 0) ? field->width : -field->width;
-    if (width > columns - start)
-        width = columns - start;
+    if (width > columns*status_height - start)
+        width = columns*status_height - start;
     if (width < 0)
 	width = 0;
     return width;
@@ -1548,7 +1550,7 @@
 	}
         if (internal >= 0 && field->internal != internal) continue;
 	column = status_field_column(field);
-	if (column >= columns) /* doesn't fit, nor will any later fields */
+	if (column >= columns*status_height) /* doesn't fit, nor will any later fields */
 	    break;
 	count++;
         width = format_status_field(field);
@@ -1589,12 +1591,12 @@
     for (node = status_field_list->head; node; node = node->next) {
         field = (StatusField*)node->datum;
 
-	if ((column = status_field_column(field)) >= columns)
+	if ((column = status_field_column(field)) >= columns*status_height)
 	    break;
         width = format_status_field(field);
     }
 
-    for (column += width; column < columns; column++) {
+    for (column += width; column < columns*status_height; column++) {
 	status_line->data[column] = true_status_pad;
 	status_line->charattrs[column] = status_attr;
     }
@@ -1602,23 +1604,33 @@
 
 int display_status_line(void)
 {
+    int i;
     if (screen_mode < 1) return 0;
 
     if (!alert_len) {
 	/* no overlap with alert */
-	xy(1, ystatus);
-	hwrite(status_line, 0, columns, 0);
+	for (i=0;i<status_height;i++) {
+ 	  xy(1, ystatus+i);
+	  hwrite(status_line, (columns*i), columns, 0);
+        }
     } else {
 	/* overlap with alert (this could happen in ch_status_attr()) */
-	if (alert_pos > 0) {
-	    xy(1, ystatus);
-	    hwrite(status_line, 0, alert_pos, 0);
-	}
-	if (alert_pos + alert_len < columns) {
-	    xy(alert_pos + alert_len + 1, ystatus);
-	    hwrite(status_line, alert_pos + alert_len,
-		columns - (alert_pos + alert_len), 0);
+	for (i=0;i<status_height;i++) {
+	 if (!i) {
+		if (alert_pos > 0) {
+		    xy(1, ystatus);
+		    hwrite(status_line, 0, alert_pos, 0);
+		}
+		if (alert_pos + alert_len < columns) {
+		    xy(alert_pos + alert_len + 1, ystatus);
+		    hwrite(status_line, alert_pos + alert_len,
+			columns - (alert_pos + alert_len), 0);
+		}
+        } else {
+ 	  xy(1, ystatus+i);
+	  hwrite(status_line, (columns*i), columns, 0);
 	}
+       }
     }
 
     bufflush();
@@ -1710,11 +1722,12 @@
 int ch_visual(void)
 {
     static int old_isize = 0;
+    static int old_height = 0;
     int need_redraw;
 
-    if (status_line->len < columns)
-	Stringnadd(status_line, '?', columns - status_line->len);
-    Stringtrunc(status_line, columns);
+    if (status_line->len < columns*status_height)
+	Stringnadd(status_line, '?', columns*status_height - status_line->len);
+    Stringtrunc(status_line, columns*status_height);
 
     if (screen_mode < 0) {                /* e.g., called by init_variables() */
         need_redraw = 0;
@@ -1728,6 +1741,11 @@
 #ifdef SCREEN
     } else if (isize != old_isize) {      /* %isize changed */
         need_redraw = 1;
+    } else if (status_height != old_height) {      /* %status_height changed */
+        if (status_height > MAX_STATUS_HEIGHT) {
+          set_var_by_id(VAR_stat_height, MAX_STATUS_HEIGHT);
+        } 
+        need_redraw = 1;
     } else {                              /* SIGWINCH */
         /* Set ystatus to the top of the area fix_screen() must erase. */
         /* ystatus = 1; */
@@ -1742,6 +1760,7 @@
         transmit_window_size();
     }
     old_isize = isize;
+    old_height = status_height;
     return 1;
 }
 
@@ -1810,9 +1829,9 @@
 static void clear_input_window(void)
 {
     /* only called in visual mode */
-    clear_lines(ystatus + 1, lines);
+    clear_lines(ystatus + status_height, lines);
     ix = iendx = 1;
-    iy = iendy = istarty = ystatus + 1;
+    iy = iendy = istarty = ystatus + status_height;
     ipos();
 }
 
@@ -1830,14 +1849,14 @@
 static void scroll_input(int n)
 {
     if (n > isize) {
-        clear_lines(ystatus + 1, lines);
-        iendy = ystatus + 1;
+        clear_lines(ystatus + status_height, lines);
+        iendy = ystatus + status_height;
     } else if (delete_line) {
-        xy(1, ystatus + 1);
+        xy(1, ystatus + status_height);
         for (iendy = lines + 1; iendy > lines - n + 1; iendy--)
             tp(delete_line);
     } else if (has_scroll_region) {
-        setscroll(ystatus + 1, lines);
+        setscroll(ystatus + status_height, lines);
         xy(1, lines);
         crnl(n);  /* DON'T: cy += n; */
         iendy = lines - n + 1;
@@ -1986,7 +2005,7 @@
             iendx = ix = 1;
         } else if (scroll && !clearfull) {
             scroll_input(1);
-            if (istarty > ystatus + 1) istarty--;
+            if (istarty > ystatus + status_height) istarty--;
         } else {
             clear_input_window();
         }
@@ -2176,7 +2195,7 @@
             ioutall(place - (ix - 1) - (iy - lines - 1) * Wrap);
             iy = lines;
             ipos();
-        } else if ((iy < ystatus + 1) || (iy > lines)) {
+        } else if ((iy < ystatus + status_height) || (iy > lines)) {
             logical_refresh();
         } else {
             ipos();
diff -ur tf-50b3/src/varlist.h tfmod/src/varlist.h
--- tf-50b3/src/varlist.h	Tue Jan  6 01:11:05 2004
+++ tfmod/src/varlist.h	Mon Jan  5 23:35:36 2004
@@ -114,6 +114,7 @@
 varflag(VAR_sockmload,	"sockmload",	FALSE,		NULL)
 varstr (VAR_stat_attr,	"status_attr",	NULL,		ch_status_attr)
 varstr (VAR_stat_fields,"status_fields",NULL,		ch_status_fields)
+varint (VAR_stat_height,"status_height",1,		ch_visual)
 varstr (VAR_stat_pad,	"status_pad",	"_",		update_status_line)
 varstr (VAR_stint_clock,"status_int_clock",NULL,	ch_status_int)
 varstr (VAR_stint_more,	"status_int_more",NULL,		ch_status_int)
